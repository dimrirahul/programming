 Like many combinatorial games problems, this one is solvable with dynamic programming. The solution can be broken into two steps. First, lets identify for which numbers of stones the player to make the next move has a winning strategy regardless of how the other players move. This is quite similar to identifying winning positions in usual 2 players game, but things become a little bit more complicated because we can have more than 2 players. To solve this part we can calculate the following values:

    canWin(i): assume there are currently i stones left on the table. Does the player to make the next move have a winning strategy regardless of how the other players move?
    canMakeNotWin(i, j): assume there are currently j stones and player i (i ≥ 1) should make the next move. Do players 1, 2, ..., k-1 have a collaborate strategy that makes it certain that player 0 won't win the game regardless of his moves? 

To calculate this functions, the following rules can be used:

    canWin(i) is true if we can take all i stones in one move or if we can take some number of stones x < i such that canMakeNotWin(1, i - x) is false (after we take x stones, the player 1 will be left with i - x stones; we can win if from this situation the other players don't have a collaborate strategy that makes it certain that we don't win).
    canMakeNotWin(i, j), i ≠ k - 1, is true if there are no possible moves for i-th player (nobody will win in this case), if he can take all stones in one move or if there is a move consisting of taking x < j stones such that canMakeNotWin(i + 1, j - x) is true (after we take x stones, the player i + 1 will be left with j - x stones and should be able to successfully proceed the collaboration strategy that forces the player 0 to not win).
    canMakeNotWin(k - 1, j) is true is there are no possible moves for i-th player, if he can take all stones in one move or if there is a move consisting of taking x < j stones such that canWin(j - x) is false (the player 0 will be left with j - x stones and should not be able to win). 

Now, the second step of our solution consists of calculating the sets winPrb(i), 1 ≤ i ≤ n. Each of these sets contains all players who have a non-zero probability of winning the game, which starts from i stones and player 0 makes the first move. If canWin(i) is true, then player 0 will follow his winning strategy, so winPrb(i) = {0}. If canWin(i) is false, then we need to check whether player 0 can ensure his win with a non-zero probability (assuming all other players follow the same strategy). To do this, let's iterate through all possible moves x and check sets winPrb(i - x). Suppose at least one of this sets contain player k - 1. It means that if player 0 started the game with i - x stones, then player k - 1 would have a positive chance to win. Similarly, if player 1 (the next after 0) started the game with i - x stones, then player 0 (the next after k - 1) would also have a positive chance to win. So moves x such that winPrb(i - x) contains player k - 1 guarantee positive winning chances to player 0. If there's at least one such move, he will randomly do one of such moves.

Let's define the right shift of a set A as the set B where each player i from the set A is replaced by player i+1 (player k-1 is replaced by player 0). If player 0 started the game with i - x stones, then winPrb(i - x) would give us all players who have chances to win. Similarly, if player 1 started the game with i - x stone, then all players who can win would be described by the right shift of winPrb(i - x). Now it's easy to see the algorithm of calculation of winPrb(i): if at least one of sets winPrb(i - x) contains player k - 1, then winPrb(i) is the union of the right shifts of all such sets, otherwise winPrb(i) is the union of all possible sets winPrb(i - x).

After winPrb is calculated, the answer is just winPrb(n).

Exercise. It may seem true that canWin(i) is true if and only if winPrb(i) = {0}. If it were true, there would be no need in calculating canWin and canMakeNotWin, so solution would become much easier. Show that it's not true by constructing an example where winPrb(i) = {0} and canWin(i) is false.
